<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demonstração de WebAuthn com TypeScript</title>
    <!-- Incluindo Tailwind CSS para estilização -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 
      NOTA DE PERMISSÃO:
      Se você estiver incorporando esta página em um <iframe>, a WebAuthn API
      exigirá que você adicione o atributo 'allow' à tag do iframe para funcionar.
      Exemplo: 
      <iframe src="..." allow="publickey-credentials-create *; publickey-credentials-get *"></iframe>
    -->
    <style>
        /* Estilo para animação de carregamento */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen font-sans">

    <div class="w-full max-w-md bg-white rounded-xl shadow-lg p-8 space-y-6">
        <div class="text-center">
            <h1 class="text-3xl font-bold text-gray-800">WebAuthn Demo</h1>
            <p class="text-gray-500 mt-2">Autenticação sem senha com TypeScript</p>
        </div>
        
        <!-- Campo de nome de usuário -->
        <div>
            <label for="username" class="text-sm font-semibold text-gray-600 block mb-2">Nome de Usuário</label>
            <input type="text" id="username" placeholder="Digite seu nome de usuário" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition">
        </div>

        <!-- Botões de Ação -->
        <div class="flex flex-col sm:flex-row gap-4">
            <button id="registerBtn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-all duration-300 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
                <span class="btn-text">Registrar com Digital</span>
                <div class="loader hidden"></div>
            </button>
            <button id="loginBtn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-all duration-300 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
                 <span class="btn-text">Entrar com Digital</span>
                 <div class="loader hidden"></div>
            </button>
        </div>

        <!-- Área de Status -->
        <div id="status" class="text-center text-sm text-gray-600 pt-4 border-t border-gray-200">
            Pronto para começar.
        </div>
    </div>

    <script type="module">
        const usernameInput = document.getElementById('username');
        const registerBtn = document.getElementById('registerBtn');
        const loginBtn = document.getElementById('loginBtn');
        const statusDiv = document.getElementById('status');

        function arrayBufferToBase64Url(buffer) {
            return btoa(String.fromCharCode(...new Uint8Array(buffer)))
                .replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
        }

        function base64UrlToArrayBuffer(base64Url) {
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        const userDatabase = new Map();

        async function mockServer_getRegistrationChallenge(username) {
            if (userDatabase.has(username)) throw new Error(`Usuário '${username}' já existe.`);
            const challenge = crypto.getRandomValues(new Uint8Array(32));
            userDatabase.set(username, { challenge });
            return {
                challenge: arrayBufferToBase64Url(challenge),
                rp: { name: "WebAuthn Demo App" },
                user: { id: arrayBufferToBase64Url(crypto.getRandomValues(new Uint8Array(16))), name: username, displayName: username },
                pubKeyCredParams: [{ type: "public-key", alg: -7 }, { type: "public-key", alg: -257 }],
                authenticatorSelection: { authenticatorAttachment: "platform", userVerification: "required" },
                timeout: 60000, attestation: "direct",
            };
        }

        async function mockServer_verifyRegistration(username, attestationResponse) {
            const user = userDatabase.get(username);
            if (!user) throw new Error("Usuário não encontrado.");
            console.log("Resposta de registro recebida no servidor:", attestationResponse);
            user.credential = { id: attestationResponse.id, publicKey: "CHAVE_PUBLICA_SIMULADA", algorithm: -7 };
            delete user.challenge;
            console.log("Usuário registrado com sucesso:", user);
            return { success: true };
        }

        async function mockServer_getLoginChallenge(username) {
            const user = userDatabase.get(username);
            if (!user || !user.credential) throw new Error(`Usuário '${username}' não registrado.`);
            const challenge = crypto.getRandomValues(new Uint8Array(32));
            user.challenge = challenge;
            return {
                challenge: arrayBufferToBase64Url(challenge),
                allowCredentials: [{ type: 'public-key', id: user.credential.id, transports: ['internal'] }],
                userVerification: 'required', timeout: 60000,
            };
        }

        async function mockServer_verifyLogin(username, assertionResponse) {
             const user = userDatabase.get(username);
             if (!user) throw new Error("Usuário não encontrado.");
             console.log("Resposta de login recebida no servidor:", assertionResponse);
             delete user.challenge;
             return { success: true };
        }

        function updateStatus(message, isError = false) {
            statusDiv.textContent = message;
            statusDiv.className = isError 
                ? 'text-center text-sm text-red-600 pt-4 border-t border-gray-200' 
                : 'text-center text-sm text-gray-600 pt-4 border-t border-gray-200';
        }

        function toggleButtonLoading(button, isLoading) {
            const btnText = button.querySelector('.btn-text');
            const loader = button.querySelector('.loader');
            button.disabled = isLoading;
            if (isLoading) {
                btnText.style.display = 'none';
                loader.style.display = 'block';
            } else {
                btnText.style.display = 'block';
                loader.style.display = 'none';
            }
        }

        async function handleRegister() {
            const username = usernameInput.value;
            if (!username) {
                updateStatus("Por favor, digite um nome de usuário.", true);
                return;
            }
            toggleButtonLoading(registerBtn, true);
            updateStatus("Iniciando registro...");
            try {
                const creationOptions = await mockServer_getRegistrationChallenge(username);
                creationOptions.challenge = base64UrlToArrayBuffer(creationOptions.challenge);
                creationOptions.user.id = base64UrlToArrayBuffer(creationOptions.user.id);
                updateStatus("Aguardando sua impressão digital...");
                const credential = await navigator.credentials.create({ publicKey: creationOptions });
                const attestationResponse = {
                    id: credential.id, rawId: arrayBufferToBase64Url(credential.rawId),
                    response: { clientDataJSON: arrayBufferToBase64Url(credential.response.clientDataJSON), attestationObject: arrayBufferToBase64Url(credential.response.attestationObject) },
                    type: credential.type,
                };
                updateStatus("Verificando registro...");
                const verificationResult = await mockServer_verifyRegistration(username, attestationResponse);
                if (verificationResult.success) updateStatus(`Usuário '${username}' registrado com sucesso!`);
                else throw new Error("Falha na verificação do servidor.");
            } catch (err) {
                updateStatus(`Erro no registro: ${err.message}`, true);
                console.error("Erro de Registro:", err);
            } finally {
                toggleButtonLoading(registerBtn, false);
            }
        }
        
        async function handleLogin() {
            const username = usernameInput.value;
            if (!username) {
                updateStatus("Por favor, digite um nome de usuário.", true);
                return;
            }
            toggleButtonLoading(loginBtn, true);
            updateStatus("Iniciando login...");
            try {
                const requestOptions = await mockServer_getLoginChallenge(username);
                requestOptions.challenge = base64UrlToArrayBuffer(requestOptions.challenge);
                requestOptions.allowCredentials.forEach(cred => { cred.id = base64UrlToArrayBuffer(cred.id); });
                updateStatus("Aguardando sua impressão digital...");
                const assertion = await navigator.credentials.get({ publicKey: requestOptions });
                const assertionResponse = {
                    id: assertion.id, rawId: arrayBufferToBase64Url(assertion.rawId),
                    response: {
                        authenticatorData: arrayBufferToBase64Url(assertion.response.authenticatorData),
                        clientDataJSON: arrayBufferToBase64Url(assertion.response.clientDataJSON),
                        signature: arrayBufferToBase64Url(assertion.response.signature),
                        userHandle: assertion.response.userHandle ? arrayBufferToBase64Url(assertion.response.userHandle) : null,
                    }, type: assertion.type,
                };
                updateStatus("Verificando login...");
                const verificationResult = await mockServer_verifyLogin(username, assertionResponse);
                if (verificationResult.success) updateStatus(`Login bem-sucedido para '${username}'!`);
                else throw new Error("Falha na verificação do login.");
            } catch (err) {
                 updateStatus(`Erro no login: ${err.message}`, true);
                 console.error("Erro de Login:", err);
            } finally {
                toggleButtonLoading(loginBtn, false);
            }
        }
        window.addEventListener('load', () => {
            if (window.PublicKeyCredential === undefined || typeof window.PublicKeyCredential !== "function") {
                updateStatus("WebAuthn não é suportado neste navegador ou está num contexto inseguro (não-HTTPS).", true);
                registerBtn.disabled = true;
                loginBtn.disabled = true;
            }
        });

        registerBtn.addEventListener('click', handleRegister);
        loginBtn.addEventListener('click', handleLogin);
    </script>

</body>
</html>

